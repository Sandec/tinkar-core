package dev.ikm.tinkar.common.bind;

import dev.ikm.tinkar.common.bind.annotations.axioms.ParentConcept;
import dev.ikm.tinkar.common.bind.annotations.axioms.ParentConcepts;
import dev.ikm.tinkar.common.bind.annotations.axioms.ParentProxies;
import dev.ikm.tinkar.common.bind.annotations.axioms.ParentProxy;
import dev.ikm.tinkar.common.bind.annotations.names.FullyQualifiedName;
import dev.ikm.tinkar.common.bind.annotations.names.FullyQualifiedNames;
import dev.ikm.tinkar.common.bind.annotations.names.RegularName;
import dev.ikm.tinkar.common.bind.annotations.names.RegularNames;
import dev.ikm.tinkar.common.bind.annotations.publicid.PublicIdAnnotation;
import dev.ikm.tinkar.common.bind.annotations.publicid.UuidAnnotation;
import dev.ikm.tinkar.common.id.PublicId;
import dev.ikm.tinkar.common.id.PublicIds;
import dev.ikm.tinkar.common.util.uuid.UuidT5Generator;
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.ImmutableList;
import org.eclipse.collections.api.list.MutableList;

import java.util.UUID;


/**
 * Represents an interface defining various methods for managing and retrieving information
 * that enable treating Java classes as Tinkar Concepts. These methods include
 * the provision of default or provided public identifiers, fully qualified names, regular names,
 * and logical parents. These methods facilitate working with metadata and hierarchical relationships
 * of concept classes, and bilateral binding between java code and a dynamic knowledge representation.
 */
public interface ConceptClass {
    UUID uuidNameSpace = UUID.fromString("3520c35f-5534-42f7-90f9-8b4eb94ecb8c");


    /**
     * Retrieves a {@code PublicId} for the specified {@code ConceptClass}.
     * The method checks if the class is annotated with {@code PublicIdAnnotation}.
     * If the annotation is present, the UUIDs defined in the annotation are used to create the {@code PublicId}.
     * If the annotation is absent, a new {@code PublicId} is generated by combining a predefined namespace
     * with the class's name using the {@code UuidT5Generator}.
     *
     * @param conceptClass the class implementing {@code ConceptClass} whose {@code PublicId} is to be retrieved
     * @return the corresponding {@code PublicId} for the given {@code ConceptClass}
     */
    static dev.ikm.tinkar.common.id.PublicId publicId(Class<? extends ConceptClass> conceptClass) {
        MutableList<UUID> uuids = Lists.mutable.empty();
        PublicIdAnnotation publicIdAnnotation = conceptClass.getAnnotation(PublicIdAnnotation.class);
        if (publicIdAnnotation != null) {
            for (UuidAnnotation uuidAnnotation : publicIdAnnotation.value()) {
                uuids.add(UUID.fromString(uuidAnnotation.value()));
            }
        }
        if (uuids.isEmpty()) {
            uuids.add(UuidT5Generator.get(uuidNameSpace, conceptClass.getName()));
        }
        return PublicIds.of(uuids);
    }

    /**
     * Retrieves the {@code PublicId} associated with the implementing class of the {@code ConceptClass} interface.
     * The {@code PublicId} is determined using the class-level {@code PublicIdAnnotation} if present.
     * If no annotation is found, a default UUID is generated based on this interface's uuidNameSpace and
     * the implementation class's class name.
     *
     * @return the {@code PublicId} corresponding to the implementing class
     */
    default PublicId publicId() {
        return publicId(this.getClass());
    }

    /**
     * Retrieves an immutable list of fully qualified names associated with the implementing class.
     * The method evaluates the {@link FullyQualifiedNames} annotation, if present, on the class.
     * Each {@link FullyQualifiedName} annotation within the {@link FullyQualifiedNames} annotation
     * is processed to extract its value and add it to the list of fully qualified names.
     *
     * If the list of fully qualified names is empty, the method falls back to retrieving {@code regularNames}.
     * If no {@code regularNames} are found, a default fully qualified name is generated using the class's simple name
     * in a readable format along with its package name.
     *
     * @return an immutable list of fully qualified names (`ImmutableList<String>`) representing descriptive,
     * unique identifiers for the implementing class.
     */
    default ImmutableList<String> fullyQualifiedNames() {
        FullyQualifiedNames fullyQualifiedNamesAnnotation = this.getClass().getAnnotation(FullyQualifiedNames.class);
        MutableList<String> fullyQualifiedNames = Lists.mutable.empty();
        for (FullyQualifiedName fullyQualifiedName: fullyQualifiedNamesAnnotation.value()) {
            fullyQualifiedNames.add(fullyQualifiedName.value());
        }
        if (fullyQualifiedNames.isEmpty()) {
            ImmutableList<String> regularNames = regularNames();
            if (regularNames.notEmpty()) {
                fullyQualifiedNames.add(regularNames.getAny());
            } else {
                fullyQualifiedNames.add(camelCaseToWords(this.getClass().getSimpleName()) + ", from package " +
                        this.getClass().getPackage().getName());
            }
        }
        return fullyQualifiedNames.toImmutable();
    }

    /**
     * Retrieves an immutable list of regular names associated with the implementing class.
     * The method evaluates the {@link RegularNames} annotation, if present, on the class.
     * Each {@link RegularName} annotation within the {@link RegularNames} annotation is processed
     * to extract its value and add it to the list of regular names.
     *
     * If the implementing class does not have a {@link RegularNames} annotation or if the list of
     * names extracted from the annotation is empty, the method generates a default regular name
     * by converting the class's simple name from camelCase to a space-separated format.
     *
     * @return an immutable list of regular names (`ImmutableList<String>`) representing descriptive
     * labels or names for the implementing class.
     */
    default ImmutableList<String> regularNames() {
        RegularNames regularNamesAnnotation = this.getClass().getAnnotation(RegularNames.class);
        MutableList<String> regularNames = Lists.mutable.empty();
        for (RegularName regularName: regularNamesAnnotation.value()) {
            regularNames.add(regularName.value());
        }
        if (regularNames.isEmpty()) {
            regularNames.add(camelCaseToWords(this.getClass().getSimpleName()));
        }
        return regularNames.toImmutable();
    }

    /**
     * Retrieves an immutable list of {@link PublicId} objects representing the logical parents of the implementing class.
     * The method collects parent identifiers through annotations declared on the class, specifically {@link ParentProxies}
     * and {@link ParentConcepts}. These annotations provide hierarchical information about the entity or concept the
     * class represents.
     *
     * For {@link ParentProxies}, the method processes each {@link ParentProxy} annotation to extract UUIDs using the
     * associated {@link PublicIdAnnotation}, and creates a {@link PublicId} for each logical parent.
     *
     * Similarly, for {@link ParentConcepts}, information about the annotated parent {@link ConceptClass} is gathered.
     * If the parent class is annotated with {@link PublicIdAnnotation}, the corresponding {@link PublicId} is constructed
     * from the UUIDs provided in the annotation.
     *
     * @return an {@link ImmutableList} of {@link PublicId} objects representing the logical parents
     */
    default ImmutableList<PublicId> parents() {
        MutableList<PublicId> parents = Lists.mutable.empty();

        ParentProxies parentProxies = this.getClass().getAnnotation(ParentProxies.class);
        for (ParentProxy parentProxy: parentProxies.value()) {
            MutableList<UUID> parentUuids = Lists.mutable.empty();
            PublicIdAnnotation publicUuidAnnotation = parentProxy.parentPublicId();
            for (UuidAnnotation uuidAnnotation : publicUuidAnnotation.value()) {
                parentUuids.add(UUID.fromString(uuidAnnotation.value()));
            }
            parents.add(PublicIds.of(parentUuids));
        }
        ParentConcepts parentConcepts = this.getClass().getAnnotation(ParentConcepts.class);
        for (ParentConcept parentConcept: parentConcepts.value()) {
            MutableList<UUID> parentUuids = Lists.mutable.empty();
            Class<? extends ConceptClass> parentClass = parentConcept.value();
            PublicIdAnnotation publicUuidAnnotation = parentClass.getAnnotation(PublicIdAnnotation.class);
            if (publicUuidAnnotation != null) {
                for (UuidAnnotation uuidAnnotation : publicUuidAnnotation.value()) {
                    parentUuids.add(UUID.fromString(uuidAnnotation.value()));
                }
            }
        }
        return parents.toImmutable();
    }

     /**
      * Converts a given camelCase string into a space-separated string,
      * where each word starts with the lowercase form of the corresponding uppercase letters in the original string.
      *
      * @param camelCaseString the input string in camelCase format
      * @return the converted string with words separated by spaces
      */
     static String camelCaseToWords(String camelCaseString) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < camelCaseString.length(); i++) {
            char ch = camelCaseString.charAt(i);

            if (Character.isUpperCase(ch)) {
                if (i > 0) {
                    result.append(" ");
                }
                result.append(Character.toLowerCase(ch));
            } else {
                result.append(ch);
            }
        }
        return result.toString();
    }

}
